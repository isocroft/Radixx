{"version":3,"sources":["webpack://Radixx/webpack/universalModuleDefinition","webpack://Radixx/webpack/bootstrap","webpack://Radixx/./src/es/utils/routines/basics.js","webpack://Radixx/./src/es/utils/routines/extras.js","webpack://Radixx/./src/es/index.js","webpack://Radixx/./src/es/components/observable.js","webpack://Radixx/./node_modules/process/browser.js","webpack://Radixx/(webpack)/buildin/global.js","webpack://Radixx/./src/es/components/dispatcher.js","webpack://Radixx/./src/es/utils/helpers.js","webpack://Radixx/./src/es/utils/primitive-checkers.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","wind","process","toString","navigator","product","global","self","Hop","Slc","slice","each","obj","iterator","context","prop","undefined","curry","func","args","_args","arguments","apply","concat","futuresStates","STARTED","AWAIT","RESOLVED","REJECTED","Routines","opts","options","_opts","String","split","savedData","formatOptions","fireStart","fireEnd","index","fired","firing","pending","queue","multiple","fire","data","$decline","save","length","setTimeout","shift","unpack","add","len","start","arg","_typeof","push","join","this","disable","hasFn","fn","result","val","hasList","fireWith","isNullOrUndefined","extend","source","dest","merge","Futures","defTracks","resolve","reject","notify","keys","setter","fnName","arr","forPromise","drop","state","ax","promise","splice","always","done","fail","then","ret","forEach","item","rt","e","isResolved","isRejected","pipe","AWAITING","_basics","__unload","onbeforeunload","onunload","__hasDeactivated","_checkAndKillEventPropagation","event","type","stopPropagation","cancelBubble","Values","typesMap","number","Number","array","Array","string","boolean","Boolean","date","Date","regexp","RegExp","function","Function","isOfType","toLowerCase","test","Store","dependentStores","title","getTitle","toJSON","makeTrait","callback","argsLeft","unshift","waitsFor","Action","id","getId","$createBeforeTearDownCallback","config","lastActivatedNode","currentFocusElement","explicitOriginalTarget","srcDocument","activeElement","currentTarget","document","srcElement","target","leaveMessage","isLogoff","hasAttribute","getAttribute","includes","runtime","shutDownHref","href","__timeOutCallback","lock","beforeUnloadTimer","indexOf","returnValue","_confirm","confirm","clearTimeout","$createTearDownCallback","hub","appstate","eachStore","store","next","getState","disconnect","destroy","_ping","observable","_extras","_helpers","_primitiveCheckers","purgePersistentStorage","purgePersistStore","stores","isAppStateAutoRehydrated","onDispatch","handler","watchDispatcher","_hub","Helpers","Payload","makeStore","dataTitle","registerCallback","defaultStateObj","storeObject","_len","_key","setStoreObserver","makeActionCreators","vectors","actionObject","_len2","_key2","registerAction","setActionVectors","requestAggregator","makeAggregator","configure","mergeConfig","attachMiddleware","setMiddlewareCallback","onShutdown","setupShutdownCallback","_dispatcher","$instance","getInstance","Dispatcher","getObjectPrototype","getPrototypeOf","__proto__","constructor","createStoreInterface","dispatcher","method","regFunc","argument","setStoreListener","unsetStoreListener","Area","getRegistration","$$history","del","unregister","signalUnique","actionData","$$historyIndex","register","handleStoreMutation","createActionInterface","vector","TypeError","stateAspectKey","typesBitMask","addToActonsRegistry","actionDefinition","definition","signal","actionType","actionKey","extractor","storeArray","iterateOnStore","query","regId","Math","random","substr","setActionsRegistry","userConfig","initCatchers","deletePersistenceTagAndData","middlewareFunc","getMiddleware","ex","setMiddleware","_proto","creator","methods","watch","getAutoRehydrationState","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","currentQueue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","g","eval","CustomEvent","CEvent","w","Event","persistStore","top","localStorage","sessStore","sessionStorage","opera","scriptStorage","documentMode","autoRehydrationOccured","watchers","storeKeys","observers","_promises","waitQueue","cachedStorageKeys","dispatchRegistry","getAppOriginForPersist","cfg","location","origin","localHostDev","documentElement","generateTag","_cdata","getItem","replace","substring","getNormalized","defaultConfig","spaMode","persistenceEnabled","autoRehydrate","universalCoverage","operationOnStoreSignal","queueing","area","action","$$initData","newStoreState","coverageNotifier","$$historyLocation","put","$$currentStoreTitle","$$withAction","eType","detail","globale","evt","cancelable","bubbles","setCapture","triggerEvt","url","newValue","aspect","JSON","parse","setNormalized","stringify","getActionOnStack","actionsStack","$$redoActionsStack","appState","currentAction","_tag","$$tag","setItem","historyLoc","fireWatchers","omitCallback","pos","watcher","$$canOmit","setAppState","isolatedState","storeTitle","getAppState","appStateData","indexStart","indexEnd","_data","observer","console","log","handlePromises","enforceCoverage","_action","_state","_title","_hloc","_composedData","_origin","$$origin","parseInt","stateWatcher","$$store_listeners","params","createEvent","initCustomEvent","createEventObject","isIE8Storage","begin","commit","values","removeItem","_classCallCheck","middlewares","$$undoActionsStack","middleware","updateAutoRehydrationState","addEventListener","attachEvent","defaultStoreContainer","hydrateAction","stateArea","historyIndex","mutationType","canUndo","canRedo","callable","prevIndex","compactedFunc","baseDispatchCallback","prevState","boundBaseDispatchCallback","adjoiner","createDispatchResolver","_hasMiddleware","hasMiddleware","reduceRight","bound","actionTypes","isEqual","former","latter","keysA","keysB","bHasOwnProperty","error","nullable","numeric","Int","isFinite","Float","parseFloat","any"],"mappings":"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","file":"radixx.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Radixx\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Radixx\"] = factory();\n\telse\n\t\troot[\"Radixx\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\r\nconst wind = (('undefined' !== typeof process &&\r\n    '[object process]' === ({}).toString.call(process)) ||\r\n  ('undefined' !== typeof navigator && navigator.product === 'ReactNative')\r\n? global : typeof window !== \"undefined\" ? window : self);\r\n\r\nconst Hop = ({}).hasOwnProperty;\r\n\r\nconst Slc = ([]).slice;\r\n\r\nconst isNullOrUndefined = obj => obj == void 0;\r\n\r\n\r\nconst each = (obj, iterator, context) => {\r\n\t\r\n\tif(context === undefined){\r\n\r\n\t\t    context = null;\r\n\t}\r\n\r\n\tfor(let prop in obj){\r\n\t\t  if(Hop.call(obj, prop)){\r\n\t\t\t    iterator.call(context, obj[prop], prop, obj);\r\n\t\t  }\r\n\t}\r\n};\r\n\r\n/**\r\n *\r\n * @params\r\n * @params\r\n * @return\r\n */\r\n\r\nconst extend = (source, dest) => {\r\n\r\n\t let merge = {};\r\n\r\n\t for(let prop in dest){\r\n  \t\tif(Hop.call(dest, prop)){\r\n\r\n    \t\t\tif(typeof dest[prop] === \"object\"\r\n    \t \t\t\t&& dest[prop] !== null){\r\n    \t\t\t \tmerge[prop] = extend(source[prop], dest[prop]);\r\n    \t\t\t }else if(source && Hop.call(source, prop)){\r\n    \t\t\t \tmerge[prop] = source[prop];\r\n    \t\t\t }else {\r\n    \t\t\t \tmerge[prop] = dest[prop];\r\n    \t\t\t }\r\n  \t\t}\r\n\t }\r\n\r\n\treturn merge;\r\n};\r\n\r\nconst curry = (func, args, context) => function(){\r\n    let _args = Slc.call(arguments);\r\n    return func.apply(context, args.concat(_args)); \r\n};\r\n\r\nconst futuresStates = {\r\n     STARTED:0,\r\n     AWAIT:1,\r\n     RESOLVED:2,\r\n     REJECTED:3\r\n};\r\n\r\nconst formatOptions = opts => {\r\n     const options = {}, _opts = String(opts).split(\",\");\r\n     each(_opts, key => {\r\n           options[key] = true;\r\n     });\r\n     options.savedData = !1;\r\n     return options;\r\n};\r\n\r\nconst Routines = opts => {\r\n    const options = formatOptions(opts);\r\n    let fireStart;\r\n    let fireEnd;\r\n    let index;\r\n    let fired;\r\n    let firing;\r\n    let pending = [];\r\n    let queue = options.multiple && [];\r\n\r\n    const fire = data => {\r\n          options.savedData = !fire.$decline && options.save && data; // save it only when we are not rejecting {fire.$decline != true}!\r\n          fired = true;\r\n          firing = true; // firing has begun!\r\n          index = fireStart || 0;\r\n          fireEnd = pending.length;\r\n\t    \r\n          for(fireStart = 0; index < fireEnd; index++){\r\n                 // @TODO: need to curry args instead of directly binding them #DONE\r\n               wind.setTimeout(curry(pending[index], data[1], data[0])/*.bind(data[0], data[1])*/, 20); // fire asynchronously (Promises/A+ spec requirement)\r\n          }\r\n\t    \r\n          firing = false; // firing has ended!\r\n\r\n          if(queue){ // deal with the queue if it exists and has any contents...\r\n              if(queue.length){\r\n                  return fire(queue.shift()); // fire on the {queue} items recursively\r\n              }\r\n               // if queue is empty.... then end [flow of control] at this point!\r\n          }\r\n\r\n          fire.$decline = false;\r\n          \r\n          if(options.savedData){\r\n             if(options.unpack){\r\n                 // clear our {pending} list and free up some memeory!!\r\n                 pending.length = 0; // saves the reference {pending} and does not replace it!\r\n             }\r\n          }\r\n };\r\n\r\n    return {\r\n    add() {\r\n        let len = 0;\r\n        if(pending){ // if not disbaled\r\n            \r\n            const start = pending.length;\r\n            (function add(args){\r\n             \r\n                   each(args, arg => {\r\n\t\t\t  const type = typeof arg;\r\n                          \r\n                          if(type == \"function\"){\r\n                             \tlen = pending.push(arg);\r\n                          }else{\r\n                             if(!!arg && arg.length && typeof arg != \"string\"){\r\n                             \t // inspect recursively\r\n                                 add(Slc.call(arg)); \r\n                             }\r\n                          }\r\n                   });\r\n             \r\n             }(Slc.call(arguments)));\r\n            \r\n            \r\n\t\t\tif( fired ){ // if we have already run the {pending} list of routines at least once, ...\r\n\t\t\t\t   if(options.join){\r\n\t\t\t\t\t  fireStart = start; \r\n\t\t\t\t\t  fireEnd = len; // update info again...\r\n\t\t\t\t\t  fire.$decline = true;\r\n\t\t\t\t\t  fire( options.savedData ); // fire with the saved data \r\n\t\t\t\t\t  this.disable();\r\n\t\t\t\t\t  \r\n\t\t\t\t   }  \r\n\t\t\t}\r\n            \r\n            \r\n        }\r\n        return len;\r\n    },\r\n    hasFn(fn) {\r\n\t    \tlet result = false;\r\n            \teach(pending, val => {\r\n\t\t     if(typeof fn === \"function\" && fn === val)\r\n\t\t\t      result = true;\r\n\t\t}, this);\r\n\t\treturn result;\r\n    },\r\n    hasList() {\r\n        return !!pending; // [false] only when the disabled(); method has been called!!\r\n    },\r\n    fireWith() /* context, args */{\r\n        if(pending && (!fired || queue)){\r\n            const args = arguments.length && Slc.call(arguments) || [null, 0];\r\n            \r\n            if(firing){ // we are currently iterating on the {pending} list of routines\r\n                queue.push( args ); // queue assets for recursive firing within {fire} function later\r\n            }else{\r\n                fire( args );\r\n            }\r\n        }\r\n    },\r\n    disable() {\r\n\t    if(!options.savedData){\r\n             pending = queue = undefined;\r\n\t    }\r\n    }\r\n  };\r\n};\r\n\r\n// Futures constructor - Promises/A+ Spec Implementation (Influenced by jQuery though...)\r\n\r\nlet Futures = function(){\r\n\r\n    const defTracks = {\r\n        resolve:['done', 'RESOLVED', Routines(['join', 'save'])],\r\n        reject:['fail', 'REJECTED', Routines(['join','save'])],\r\n        notify:['progress', 'AWAIT', Routines(['join', 'multiple'])]\r\n    };\r\n\r\n    const self = this;\r\n    let keys = Object.keys(defTracks);\r\n\r\n    let setter = (fnName, arr, forPromise) => {\r\n        const drop = (fnName != \"notify\");\r\n        if(!arr.length && !forPromise) return defTracks[fnName][2].fireWith;\r\n        return (!forPromise)? function(){\r\n            if(self.state >= 0 && self.state <=1){\r\n                self.state = futuresStates[defTracks[fnName][1]];\r\n            }\r\n\r\n            defTracks[fnName][2].fireWith(self === this? self : this, [].slice.call(arguments));\r\n\r\n            if(drop){\r\n\t\t\t    defTracks[arr[0]][2].disable();\r\n                defTracks[arr[1]][2].disable();\r\n\t\t\t    switch(fnName){\t\r\n\t\t\t\t   case \"reject\":\r\n\t\t\t\t   case \"resolve\":\r\n\t\t\t\t      self.state = futuresStates[defTracks[fnName][1]];\r\n\t\t\t\t   break;\r\n\t\t\t    }\t\r\n\t\t\t}\r\n            return true;\r\n        } : function(){\r\n            if(self.state >= 0 && self.state <=1){\r\n                defTracks[fnName][2].add.apply(self, Slc.call(arguments));\r\n            }\r\n            return self;\r\n        } ;\r\n    };\r\n\r\n    let i = 0;\r\n    let ax = keys.slice();\r\n    let d;\r\n    const promise = {};\r\n\r\n\r\n    // using a closure to define all the functions on the fly...\r\n\r\n    for(d in defTracks){\r\n        if(Hop.call(defTracks, d)){\r\n            keys.splice(i++, 1);\r\n            self[d] = setter(d, keys);\r\n            self[`${d}With`] = setter(d, []);\r\n            promise[defTracks[d][0]] = setter(d, [], true);\r\n            keys = ax.slice();\r\n        }\r\n    }\r\n\r\n    promise.state = futuresStates.STARTED;\r\n\r\n    promise.always = function(){\r\n        return this.done.apply(self, arguments).fail.apply(self, arguments);\r\n    };\r\n\r\n    promise.promise = obj => {\r\n        if(obj && typeof obj == \"object\" && !obj.length){\r\n            for(const i in promise){\r\n                if(Hop.call(promise, i)){\r\n                    obj[i] = promise[i];\r\n                }\r\n            }\r\n            return obj;\r\n        }\r\n        return promise;\r\n    };\r\n\r\n    promise.then = function(/* fnDone, fnFail, fnProgress */){\r\n        let ret;\r\n        const args = [].slice.call(arguments);\r\n        args.forEach((item, i) => {\r\n                     item = (typeof item == \"function\") && item;\r\n                     self[defTracks[keys[i]][0]](function(){\r\n\t\t\t\t\t\t\tlet rt;\r\n\t\t\t\t\t\t\ttry{ \r\n\t\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t\t\tPromises/A+ specifies that errors should be contained\r\n\t\t\t\t\t\t\t\t\tand returned as value of rejected promise\r\n\t\t\t\t\t\t\t\t*/\r\n\t\t\t\t\t\t\t   rt = item && item.apply(this, arguments);\r\n\t\t\t\t\t\t\t}catch(e){ \r\n\t\t\t\t\t\t\t   rt = this.reject(e);\r\n\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t   if(rt && typeof rt.promise == \"function\")\r\n\t\t\t\t\t\t\t        ret = rt.promise();\t\t\t\t\t\t   \r\n\t\t\t\t\t\t\t}\t   \r\n                     });\r\n        });\r\n        return self.promise(ret);\r\n    };\r\n\r\n    promise.isResolved = () => !defTracks['reject'][2].hasList();\r\n    promise.isRejected = () => !defTracks['resolve'][2].hasList();\r\n    promise.pipe = promise.then;\r\n\r\n    promise.promise(self);\r\n\r\n    Futures.STARTED = futuresStates.STARTED;\r\n    Futures.AWAITING = futuresStates.AWAIT;\r\n    Futures.RESOLVED = futuresStates.RESOLVED;\r\n    Futures.REJECTED = futuresStates.REJECTED;\r\n\r\n    /* avoid leaking memory with each call to Futures constructor!! */\r\n    setter = ax = d = i = null;\r\n\r\n    /* enforce {new} on constructor */\r\n    return (self instanceof Futures)? self : new Futures();\r\n};\r\n\r\nexport { Hop, Slc, isNullOrUndefined, wind, each, extend, curry, Futures }\r\n","import { wind } from './basics.js';\r\n\r\nlet __beforeunload = wind.onbeforeunload;\r\n\r\nlet __unload = wind.onunload;\r\n\r\nlet __hasDeactivated = false;\r\n\r\nlet _checkAndKillEventPropagation = event => {\r\n  if(event.type === 'click'){\r\n      if(event.stopPropagation){\r\n        event.stopPropagation();\r\n      }else{\r\n        event.cancelBubble = true;\r\n      }\r\n    }\r\n};\r\n\r\nconst $createBeforeTearDownCallback = config => e => {\r\n  \r\n    // @See: https://greatgonzo.net/i-know-what-you-did-on-beforeunload/\r\n\r\n    /* \r\n         `lastActivatedNode` variable is used to track the DOM Node that last \r\n         had focus (or was clicked) just before the browser triggered the `beforeunload` event \r\n     */\r\n\r\n    const lastActivatedNode = (wind.currentFocusElement // Mobile Browsers [ Custom Property ]\r\n                || e.explicitOriginalTarget // old/new Firefox\r\n                    || (e.srcDocument && e.srcDocument.activeElement) // old Chrome/Safari\r\n                        || (e.currentTarget && e.currentTarget.document.activeElement) // Sarafi/Chrome/Opera/IE\r\n                            || e.srcElement\r\n                                || e.target);\r\n\r\n    // if the \"imaginary\" user is logging out\r\n    const leaveMessage = \"Are you sure you want to leave this page ?\";\r\n\r\n    const isLogoff = ((typeof lastActivatedNode.hasAttribute == 'function' && lastActivatedNode.hasAttribute('data-href') && lastActivatedNode.getAttribute('data-href').includes(config.runtime.shutDownHref)) \r\n                    || (('href' in lastActivatedNode) && (lastActivatedNode.href.includes(config.runtime.shutDownHref))));\r\n\r\n    const __timeOutCallback = () => {\r\n            \r\n            __hasDeactivated = __timeOutCallback.lock;\r\n\r\n    };\r\n\r\n    // console.log('Node: '+ lastActivatedNode);\r\n\r\n    __timeOutCallback.lock = __hasDeactivated = true;\r\n    let beforeUnloadTimer = wind.setTimeout(__timeOutCallback, 0);\r\n\r\n    if(isLogoff){ // IE/Firefox/Chrome 34+\r\n        if(!!~e.type.indexOf('beforeunload')){\r\n            e.returnValue = leaveMessage; \r\n        }else{\r\n            _confirm = wind.confirm && wind.confirm(leaveMessage);\r\n            \r\n            if(!_confirm){\r\n                _checkAndKillEventPropagation(e);\r\n            }\r\n        }\r\n    }else{\r\n        _checkAndKillEventPropagation(e);\r\n    }\r\n\r\n    /* if (isLogoff) isn't true, no beforeunload dialog is shown */\r\n    return ((isLogoff) ?  ((__timeOutCallback.lock = false) || leaveMessage) : wind.clearTimeout(beforeUnloadTimer));\r\n};\r\n\r\nconst $createTearDownCallback = hub => e => {\r\n\r\n    /*\r\n        This seems to be the best way to setup the `unload` event \r\n        listener to ensure that the load event is always fired even if the page\r\n        is loaded from the `bfcache` (Back-Forward-Cache) of the browser whenever\r\n        the back and/or forward buttons are used for navigation instead of links.\r\n        Registering it as a property of the `window` object sure works every time\r\n    */\r\n\r\n            if(!__hasDeactivated){\r\n\r\n                wind.setTimeout(() => {\r\n\r\n                        let appstate = {};\r\n                    \r\n                        hub.eachStore((store, next) => {\r\n\r\n                            const title = store.getTitle();\r\n\r\n                            appstate[title] = store.getState(); \r\n                        \r\n                            store.disconnect();\r\n                            store.destroy();\r\n\r\n                            next();\r\n\r\n                        });\r\n\r\n                        if(typeof hub._ping == \"function\"){\r\n\r\n                            hub._ping.call(hub, appstate);\r\n                        }\r\n\r\n                        if(e.type != 'click'){\r\n                            __unload(e);\r\n                        }\r\n\r\n                }, 0);\r\n            }\r\n};\r\n\r\nconst Values = {\r\n      typesMap:{\r\n                \"number\":Number,\r\n                \"array\":Array,\r\n                \"object\":Object,\r\n                \"string\":String,\r\n                \"boolean\":Boolean,\r\n                \"date\":Date,\r\n                \"regexp\":RegExp,\t\r\n                \"function\":Function\r\n      },\r\n      isOfType(type, value) {\r\n\r\n            if(typeof type === 'function'){\r\n                \r\n                return type(value);\r\n            }\r\n\r\n            else if(typeof type === 'string'\r\n                        && (type in this.typesMap)){\r\n                type = type.toLowerCase(); // hoisting\r\n\r\n                return (/^string|function$/.test(typeof value)) \r\n                            || (Object(value) instanceof this.typesMap[type]);\r\n            }\r\n\r\n            return false;\r\n      }\r\n};\r\n\r\n\r\n// Store Constructor\r\nconst Store = (function(){\r\n\r\n\tvar requirementTypes = ['graph-ql', 'rest'];\r\n\r\n\tvar serviceRequirementsMap = {};\r\n\r\n\tvar dependentStores = {};\r\n\t\r\n\treturn function(title){\r\n\r\n\t\tvar that = this;\r\n\r\n\t\tthis.getTitle = function(){\r\n\r\n\t\t\treturn title;\r\n\t\t};\r\n\r\n\t\tthis.toJSON = function(){\r\n\r\n\t\t\treturn {\r\n                title\r\n            };\r\n\t\t};\r\n\r\n\t\tthis.makeTrait = function(callback){\r\n\r\n\t\t\tvar argsLeft = Slc.call(arguments, 1);\r\n\r\n\t\t\tif(typeof callback === 'function'){\r\n\r\n\t\t\t\targsLeft.unshift(this);\r\n\r\n\t\t\t\treturn callback.apply(null, argsLeft);\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tthis.waitsFor = function(){\r\n\r\n\t\t\t([]).push.apply(dependentStores, Slc.call(arguments));\r\n\t\t};\r\n\r\n\t\tthis.toString = function(){\r\n\r\n\t\t\treturn \"[object RadixxStore]\";\r\n\t\t};\r\n\t}\t\r\n\r\n}());\r\n\r\n// Action constructor\r\nconst  Action = (function(){\r\n\r\n    return function(id){\r\n\r\n            this.getId = function(){\r\n\r\n                return id;\r\n            }\r\n\r\n            this.toJSON = function(){\r\n\r\n                return {\r\n                    id\r\n                }\r\n            };\r\n\r\n            this.toString = function(){\r\n\r\n                return \"[object RadixxActionCreator]\";\r\n            };\r\n    }\r\n\r\n}());\r\n\r\n\r\nexport { Values, Store, Action, $createBeforeTearDownCallback, $createTearDownCallback }","import * as observable from './components/observable.js';\r\nimport { Action, Store } from './utils/routines/extras.js';\r\nimport { Helpers } from './utils/helpers.js';\r\nimport { Payload } from './utils/primitive-checkers.js'\r\n\r\n /*!\r\n  * @lib: Radixx\r\n  * @version: 0.1.3\r\n  * @author: Ifeora Okechukwu\r\n  * @created: 30/12/2016\r\n  *\r\n  * All Rights Reserved 2016 - 2018.\r\n  * Use, reproduction, distribution, and modification of this code is subject to the terms and\r\n  * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php\r\n  *\r\n  * @desc: Implementation of Facebooks' Flux Architecture with a Twist. [ ES6 ]\r\n  */\r\n\r\n\r\nconst toString = function(){\r\n\r\n    return \"[object RadixxHub]\";\r\n}\r\n\r\nconst makeStore = function(dataTitle, registerCallback, defaultStateObj){\r\n    \r\n    function _store(...args){\r\n        Store.apply(this, [...args]);\r\n    }\r\n\r\n    const storeObject = new _store(dataTitle);\r\n\r\n    observable.setStoreObserver(storeObject, registerCallback, defaultStateObj);\r\n\r\n    return storeObject;\r\n}\r\n\r\nconst makeActionCreators = function(vectors){\r\n    function _action(...args){\r\n            Action.apply(this, [...args]);\r\n    }\r\n\r\n    const actionObject = new _action(observable.registerAction());\r\n\r\n    return observable.setActionVectors(actionObject, vectors);\r\n}\r\n\r\nconst purgePersistentStorage = function(){\r\n    \r\n    observable.purgePersistStore();\r\n}\r\n\r\nconst eachStore = function(callback){\r\n    \r\n    return observable.eachStore(\r\n        function(...args){\r\n            callback(...args);\r\n        }, function(stores, key){\r\n\r\n                this.push(stores[key]);\r\n    }, null);\r\n}\r\n\r\nconst attachMiddleware = function(callback) {\r\n\r\n    return observable.setMiddlewareCallback(function(...args){\r\n        callback(...args)\r\n    });\r\n}\r\n\r\nconst isAppStateAutoRehydrated = function() {\r\n\r\n    return observable.isAppStateAutoRehydrated();\r\n}\r\n\r\nconst onDispatch = function(handler){\r\n    \r\n    if(typeof handler === 'function'){\r\n\r\n        observable.watchDispatcher(function(...args){\r\n            handler(...args)\r\n        });\r\n    }\r\n}\r\n\r\nconst requestAggregator = function() {\r\n\r\n    return observable.makeAggregator();\r\n}\r\n\r\nlet _hub = {\r\n    eachStore,\r\n    onDispatch,\r\n    isAppStateAutoRehydrated,\r\n    purgePersistentStorage,\r\n    toString\r\n};\r\n\r\nconst configure = function(config) {\r\n    \r\n    return observable.mergeConfig(config, _hub);\r\n}\r\n\r\nconst onShutdown = function(handler){\r\n\r\n    if(typeof handler === \"function\"){\r\n\r\n        observable.setupShutdownCallback(function(...args){\r\n            handler(...args);\r\n        }, _hub);\r\n    }\r\n\r\n}\r\n\r\nexport { Helpers, Payload, makeStore, makeActionCreators, purgePersistentStorage, isAppStateAutoRehydrated, requestAggregator, configure, eachStore, attachMiddleware, onDispatch, onShutdown, toString }\r\n","import { wind, each, Hop, isNullOrUndefined } from '../utils/routines/basics.js';\r\nimport { Dispatcher, Area } from './dispatcher.js';\r\nimport { Values } from '../utils/routines/extras.js';\r\n\r\n\r\n\t\tlet $instance = null;\r\n\r\n\t\tconst getInstance = function(){\r\n\t\t\t\r\n\t\t\tif($instance === null){\r\n\r\n\t\t\t\t$instance = new Dispatcher();\r\n\t\t\t}\r\n\r\n\t\t\treturn $instance;\r\n\r\n\t\t};\r\n\r\n\t\tconst getObjectPrototype = obj => {\r\n\t\t\t\tif('getPrototypeOf' in Object){\r\n\t\t\t\t\treturn Object.getPrototypeOf(obj);\r\n\t\t\t\t}else if('__proto__' in obj){\r\n\t\t\t\t\tif(!(Hop.call(obj, '__proto__'))){\t\r\n\t\t\t\t\t\treturn (obj.__proto__);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if('constructor' in obj){\r\n\t\t\t\t\tif(!(Hop.call(obj, 'constructor'))){\t\r\n\t\t\t\t\t\treturn obj.constructor.prototype;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn obj;\r\n\t\t};\r\n\r\n\t\tconst eachStore = function(fn, extractor, storeArray) {\r\n\r\n            \tconst dispatcher = getInstance();\r\n\r\n            \treturn dispatcher.iterateOnStore(fn, extractor, storeArray);\r\n        };\r\n\r\n\t\tconst createStoreInterface = function(dispatcher, method) {\r\n\t\t\t\r\n\r\n\t\t\treturn function(){\r\n                let regFunc;\r\n                let area;\r\n                const argument = arguments.length ? arguments[0] : null;\r\n\r\n                if(method == 'setChangeListener'){\r\n\r\n\t\t\t\t\treturn dispatcher.setStoreListener(this, argument);\r\n\t\t\t\t}\r\n\r\n                if(method == 'unsetChangeListener'){\r\n\r\n\t\t\t\t\treturn dispatcher.unsetStoreListener(this, argument);\r\n\t\t\t\t}\r\n\r\n                if(method == 'getState'){\r\n\r\n\t\t\t\t\tvar title = this.getTitle(), value;\r\n\t\t\t\t\tarea = new Area(title);\r\n\t\t\t\t\tvalue = area.get();\r\n\t\t\t\t\tarea = null;\r\n\r\n\t\t\t\t\tif(value === null){\r\n\r\n\t\t\t\t\t\tregFunc = dispatcher.getRegistration(title);\r\n\r\n\t\t\t\t\t\tvalue = (regFunc.$$history.length ? regFunc.$$history[0] : null);\r\n\r\n\t\t\t\t\t}else if(typeof argument === 'string'){\r\n\r\n\t\t\t\t\t\tif(value instanceof Object){\r\n\r\n\t\t\t\t\t\t\tif(Hop.call(value, argument)){\r\n\r\n\t\t\t\t\t\t\t\tvalue = value[argument];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\r\n                if(method == 'destroy'){\r\n\r\n\t\t\t\t\tlet title, index;\r\n\r\n\t\t\t\t\tif(title in stores){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdelete stores[title];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tarea = new Area(this.getTitle());\r\n\r\n\t\t\t\t\tarea.del();\r\n\r\n\t\t\t\t\treturn (area = title = null);\r\n\t\t\t\t}\r\n\r\n                if(method == 'disconnect'){\r\n\r\n\t\t\t\t\treturn dispatcher.unregister(this.getTitle());\r\n\t\t\t\t}\r\n\r\n                if(method == 'hydrate'){\r\n\r\n\t\t\t\t\tif(isNullOrUndefined(argument)){\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn dispatcher.signalUnique({\r\n\t\t\t\t\t\tsource:method,\r\n\t\t\t\t\t\ttarget:this.getTitle(),\r\n\t\t\t\t\t\tactionData:argument\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n                if(method == 'getQuerySchema'){\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn {};\r\n\t\t\t\t}\r\n\r\n                if(method == 'setQuerySchema'){\r\n\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n                if(method == 'canUndo'){\r\n\r\n\t\t\t\t\tregFunc = dispatcher.getRegistration(this.getTitle());\r\n\r\n\t\t\t\t\treturn (regFunc.$$historyIndex != 0);\r\n\t\t\t\t}\r\n\r\n                if(method == 'swapCallback'){\r\n\r\n\t\t\t\t\treturn dispatcher.register(this.getTitle(), argument);\r\n\t\t\t\t}\r\n\r\n                if(method == 'canRedo'){\r\n\t\t\t\t\t\r\n\t\t\t\t\tregFunc = dispatcher.getRegistration(this.getTitle());\r\n\r\n\t\t\t\t\treturn (regFunc.$$historyIndex !== regFunc.$$history.length - 1);\r\n\t\t\t\t}\r\n\r\n                if(method == 'undo'){\r\n\r\n\t\t\t\t\treturn dispatcher.handleStoreMutation(this, method);\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n                if(method == 'redo'){\r\n\r\n\t\t\t\t\treturn dispatcher.handleStoreMutation(this, method);\r\n\r\n\t\t\t\t}\r\n            }\r\n\t\t\t\r\n\t\t};\r\n\r\n\t\tconst createActionInterface = function(dispatcher, vector) {\r\n\t\t\t\r\n\t\t\tif(!(vector instanceof Object)){\r\n\r\n\t\t\t\tthrow new TypeError(`Invalid Action Creator Vector, expected [object] but found [${typeof(vector)}]`);\r\n\t\t\t}\r\n\r\n\t\t\treturn function(data, stateAspectKey){\r\n\r\n\t\t\t\t // console.log('OUTER-FUNC: ', this.constructor.caller);\r\n\r\n\t\t\t\tconst id = this.getId();\r\n\t\t\t\t\r\n\t\t\t\tlet typesBitMask = 0;\r\n\r\n\t\t\t\tdispatcher.addToActonsRegistry(id, vector);\r\n\t\t\t\t\r\n\t\t\t\tif(vector.actionDefinition instanceof Array){\r\n\t\t\t\t\t\r\n\t\t\t\t\teach(vector.actionDefinition, function(definition){\r\n\t\t\t\t\t\r\n\t\t\t\t\t\ttypesBitMask |= Number(Values.isOfType(definition, data));\r\n\t\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(!typesBitMask){\r\n\t\t\t\t\t   \r\n\t\t\t\t\t\tthrow new TypeError(`Action Data Invalid for action: [${vector.type}]`);\r\n\t\t\t\t   \t}\r\n\t\t\t\t\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(!Values.isOfType(vector.actionDefinition, data)){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthrow new TypeError(`Action Data Invalid for action: [${vector.type}]`);\r\n\r\n\t\t\t\t\t}\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn dispatcher.signal({\r\n\t\t\t\t\tsource:id,\r\n\t\t\t\t\tactionType:vector.type,\r\n\t\t\t\t\tactionKey:stateAspectKey || null,\r\n\t\t\t\t\tactionData:data\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tconst watchDispatcher = function(callback) {\r\n\r\n\t\t\tconst dispatcher = getInstance();\r\n\r\n\t\t\tdispatcher.watch(callback);\r\n\t\t\t\t\t\r\n\t\t};\r\n\r\n\t\tconst isAppStateAutoRehydrated = function() {\r\n\r\n\t\t\tconst dispatcher = getInstance();\r\n\r\n\t\t\treturn dispatcher.getAutoRehydrationState();\r\n\r\n\t\t};\r\n\r\n\t\tconst setupShutdownCallback = function(callback, hub){\r\n\r\n\t\t\t\t\r\n\t\t\thub._ping = callback;\r\n\t\t\t\t\r\n\t\t};\r\n\r\n\t\tconst mergeConfig = function(userConfig, hub) {\r\n\r\n\t\t\tconst dispatcher = getInstance();\r\n\r\n\t\t\treturn dispatcher.initCatchers(userConfig, hub);\r\n\t\t};\r\n\r\n\t\tconst purgePersistStore = function() {\r\n\r\n\t\t\tconst dispatcher = getInstance();\r\n\r\n\t\t\tdispatcher.deletePersistenceTagAndData();\r\n\r\n\t\t};\r\n\r\n\t\tconst registerAction = function() {\r\n\t\t\t/* creates hex value e.g. '0ef352ab287f1' */\r\n\t\t\tconst regId = Math.random().toString(16).substr(2, 13); \r\n\t\r\n\t\t\tconst dispatcher = getInstance();\r\n\r\n\t\t\tdispatcher.setActionsRegistry(regId);\r\n\r\n\t\t\treturn regId;\r\n\r\n\t\t};\r\n\r\n\t\tconst makeAggregator = function() {\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tquery:`graphql {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}`\r\n\t\t\t\t};\r\n\t\t};\r\n\r\n\t\tconst setMiddlewareCallback = function(middlewareFunc) {\r\n\r\n\t\t\tconst dispatcher = getInstance();\r\n\r\n\t\t\t// HERE: using this try/catch for control flow and not defensive programming\r\n\t\t\ttry{\r\n\r\n\t\t\t\tdispatcher.getMiddleware();\r\n\r\n\t\t\t}catch(ex){\r\n\r\n\t\t\t\tdispatcher.setMiddleware(\r\n\t\t\t\t\tmiddlewareFunc\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tconst setActionVectors = function(object, vectors) {\r\n\r\n            const _proto = getObjectPrototype(object);\r\n            const dispatcher = getInstance();\r\n            let vector = null;\r\n\r\n            for(const creator in vectors){\r\n\t\t\t\tif(Hop.call(vectors, creator)){\r\n\t\t\t\t     vector = vectors[creator];\t\r\n\t\t\t\t     _proto[creator] = createActionInterface(dispatcher, vector);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n            return object;\r\n        };\r\n\r\n\t\tconst setStoreObserver = function(object, regFunc, defaultStateObj) {\r\n            \r\n            if(typeof regFunc !== \"function\"){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n            const _proto = getObjectPrototype(object);\r\n            const dispatcher = getInstance();\r\n            const title     = object.getTitle();\r\n            let method = null;\r\n\r\n            dispatcher.register(title, regFunc, defaultStateObj);\r\n\r\n            const methods = [\r\n            \t'setChangeListener', \r\n            \t'unsetChangeListener', \r\n            \t'getState', \r\n            \t'disconnect', \r\n            \t'getQuerySchema', \r\n            \t'canRedo', \r\n            \t'canUndo', \r\n            \t'swapCallback', \r\n            \t'undo', \r\n            \t'redo', \r\n            \t'hydrate', \r\n            \t'destroy'\r\n        \t];\r\n\r\n            for(let c=0; c < methods.length; c++){\r\n\t\t\t\tmethod = methods[c];\r\n\r\n\t\t\t\t_proto[method] = createStoreInterface(dispatcher, method);\r\n\t\t\t}\r\n\t\t};\r\n\r\nexport { eachStore, makeAggregator, registerAction, setupShutdownCallback, mergeConfig, purgePersistStore, setMiddlewareCallback, setActionVectors, setStoreObserver, watchDispatcher, isAppStateAutoRehydrated }","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","import { wind, Hop, Futures, isNullOrUndefined, each, extend } from '../utils/routines/basics.js';\r\nimport { $createBeforeTearDownCallback, $createTearDownCallback } from '../utils/routines/extras.js';\r\n\r\n    \r\ntry {\r\n      const ce = new wind.CustomEvent('test');\r\n} catch(e) {\r\n\r\n        CEvent.prototype = wind.Object.create(((w.Event && w.Event.prototype) || {}));\r\n        wind.CustomEvent = null;\r\n        wind.CustomEvent = CEvent;\r\n}\r\n\r\nconst persistStore = (wind.top !== wind || !wind.localStorage) ? null : wind.localStorage;\r\n\r\nconst sessStore = (wind.top !== wind || !wind.sessionStorage ? (wind.opera && !(Hop.call(wind, 'opera')) ? wind.opera.scriptStorage : {} ) : wind.sessionStorage);\r\n\r\nconst mode = wind.document.documentMode || 0;\r\n\r\nlet autoRehydrationOccured = false;\r\n\r\nlet config = null;\r\n\r\n    const watchers = [\r\n\r\n];\r\n\r\n    const stores = {\r\n\r\n};\r\n\r\n    const storeKeys = [\r\n\r\n];\r\n\r\n    const observers = {\r\n\r\n};\r\n\r\n    const _promises = {\r\n\r\n};\r\n\r\n    const waitQueue = [\r\n\r\n];\r\n\r\n    const cachedStorageKeys = {\r\n\r\n};\r\n\r\nconst dispatchRegistry = {\r\n    \r\n};\r\n\r\nconst getAppOriginForPersist = cfg => String(wind.location.origin + (cfg.localHostDev ? ':'+wind.document.documentElement.id : ''));\r\n\r\nconst generateTag = origin => {\r\n\r\n\tconst _cdata = persistStore.getItem(origin);\r\n\t\r\n\tif(!isNullOrUndefined(_cdata)){\r\n\r\n\t\treturn getNormalized(_cdata);\r\n\t}\r\n\r\n\treturn String(Math.random()).replace('.','x_').substring(0, 11);\r\n};\r\n\r\nconst defaultConfig = {\r\n\t\truntime:{\r\n\t\t\tspaMode:true, \r\n\t\t\tshutDownHref:''\r\n\t\t},\r\n\t\tpersistenceEnabled:false,\r\n\t\tautoRehydrate:false,\r\n\t\tuniversalCoverage:false,\r\n\t\tlocalHostDev:false\r\n};\r\n\r\nconst triggerEvt = (target, eType, detail, globale) => {\r\n        const evt = new CustomEvent(eType, {\r\n                            detail,\r\n                            cancelable:true,\r\n                            bubbles:false\r\n            }); // a stub function - just in case\r\n\r\n        let dispatch = () => false;\r\n\r\n        if((!('target' in evt)) \r\n                && evt.cancelBubble === true){\r\n\r\n            target.setCapture(true);\r\n        }\r\n\r\n        // set up cross-browser dispatch method.\r\n        dispatch = target[ (!('target' in evt) ? \"fireEvent\" : \"dispatchEvent\") ];\r\n\r\n        // Including support for IE 8 here ;)\r\n        return dispatch.apply(target, (!('target' in evt) ? [`on${eType}`, evt ] : [ evt ]));\r\n};\r\n\r\nconst operationOnStoreSignal = (fn, queueing, area, action) => { \r\n\r\n\t    // first, retrieve the very first state data and cache it\r\n\t    if(fn.$$history.length == 1 \r\n\t\t&& (!fn.$$initData)){\r\n\r\n\t \t\tfn.$$initData = fn.$$history[0];\r\n\t    }\t\t\r\n\r\n\t    // second, make sure that there is no future state to forth on\t\r\n\t    fn.$$history = fn.$$history.slice(0, fn.$$historyIndex + 1);\r\n\t    \r\n\t    // lets setup a place to store new state, also mark out the context of this call\r\n\t    let newStoreState = false, len, _key;\r\n\r\n\t    // create a new state of the store data by applying a given\r\n\t    // store callback function to the current history head\r\n\r\n\t    if(queueing === null){\r\n\r\n\t    \tif(action !== null){\r\n\r\n\t\t    \tnewStoreState = action.actionData;\r\n\r\n\t\t    }else{\r\n\r\n\t\t    \tnewStoreState = fn.$$history[fn.$$historyIndex];\r\n\t\t    }\r\n\r\n\t\t    coverageNotifier.$$historyLocation = fn.$$historyIndex;\r\n\r\n\t    }else{\r\n\t    \t\r\n\t    \tnewStoreState = fn.call(queueing, action, (area.get() || fn.$$initData));\r\n\r\n\r\n\t    }\r\n\r\n\t\tif(typeof newStoreState === 'boolean'\r\n\t\t\t|| isNullOrUndefined(newStoreState)){\r\n\t\t\t\r\n\t\t\tthrow new TypeError(\"Radixx: Application State unavailable after signal to Dispatcher\");\t\t\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t_key = area.put(newStoreState);\r\n\r\n\t\tcoverageNotifier.$$currentStoreTitle = _key;\r\n\t    \r\n\t    if(action !== null){\r\n\r\n\t    \tif(action.source !== 'hydrate'){\r\n    \t\t\t\t;\r\n\t    \t}\r\n\r\n\t    \tcoverageNotifier.$$withAction = true;\r\n\r\n\t    \ttriggerEvt(\r\n\t\t\t\t\twind.document, \r\n\t\t\t\t\t'storesignal', \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\turl:wind.location.href,\r\n\t\t\t\t\t\tkey:_key,\r\n\t\t\t\t\t\tnewValue:newStoreState,\r\n\t\t\t\t\t\tsource:wind,\r\n\t\t\t\t\t\taspect:action.actionKey,\r\n\t\t\t\t\t\ttype:action.actionType\r\n\t\t\t\t\t}, \r\n\t\t\t\t\twind\r\n\t\t\t);\r\n\r\n\t\t    // add the new state to the history list and increment\r\n\t\t    // the index to match in place\r\n\t\t    len = fn.$$history.push(newStoreState); /* @TODO: use {action.actionType} as operation Annotation */\r\n\t\t    \r\n\t\t    fn.$$historyIndex++;\r\n\r\n\t\t    coverageNotifier.$$historyLocation = fn.$$historyIndex;\r\n\r\n\t\t    if(fn.$$history.length > 21){ // can't undo/redo (either way) more than 21 moves at any time\r\n\r\n\t\t  \t\tfn.$$history.unshift();\r\n\t\t    }\r\n\r\n\t    }else{\r\n\r\n\t    \tcoverageNotifier.$$historyLocation = fn.$$historyIndex;\r\n\r\n\t    \treturn newStoreState;\r\n    \t}\r\n\t   \r\n\t};\r\n\r\n    const getNormalized = val => {\r\n\r\n\t   \tif(isNullOrUndefined(val) || val === \"null\")\r\n\t   \t\t return null;\r\n\r\n\t\ttry{\r\n\t\t\treturn JSON.parse(val);\r\n\t\t}catch(e){\r\n\t\t\treturn String(val);\r\n\t\t}\r\n\t};\r\n\r\n    const setNormalized = val => {\r\n\r\n\t   \tif(isNullOrUndefined(val)) \r\n\t   \t\tval = null;\r\n\r\n\t\ttry{\r\n\t\t\treturn JSON.stringify(val);\r\n\t\t}catch(e){\r\n\r\n\t\t\treturn String(val);\r\n\t\t}\r\n\t};\r\n\r\n\tconst getActionOnStack = (index) => {\r\n\r\n\t\tconst actionsStack = operationOnStoreSignal.$$redoActionsStack;\r\n\r\n\t\tif(actionsStack.length){\r\n\t\t\tif(typeof index !== 'number'){\r\n\t\t\t\treturn actionsStack[actionsStack.length - 1];\r\n\t\t\t}else{\r\n\t\t\t\treturn actionsStack[index];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t};\r\n\r\n    const coverageNotifier = appState => {\r\n\t    \r\n        let currentAction = null;\r\n\t    \r\n        const _tag = coverageNotifier.$$tag;\r\n\r\n        if(coverageNotifier.$$withAction === true){\r\n\t\t\tcurrentAction = getActionOnStack();\r\n\t\t\tcoverageNotifier.$$withAction = null;\r\n\t\t}else{\r\n\t\t\tcurrentAction = getActionOnStack(coverageNotifier.$$historyLocation);\r\n\t\t}\r\n\r\n        if(!isNullOrUndefined(_tag)\r\n\t\t\t&& (persistStore !== null)){\r\n\r\n\t\t\tpersistStore.setItem(_tag, setNormalized({\r\n        \t\t\tstate:appState, \r\n\t\t\t\t\taction:currentAction,\r\n\t\t\t\t\ttitle:coverageNotifier.$$currentStoreTitle, \r\n\t\t\t\t\thistoryLoc:coverageNotifier.$$historyLocation\r\n\t\t\t}));\r\n\r\n\t\t\tcoverageNotifier.$$historyLocation = null;\r\n\t\t}\r\n    };\r\n\r\n    const fireWatchers = (state, omitCallback) => {\r\n\r\n\t\tlet pos, watcher;\r\n\r\n\t\tfor(pos in watchers){\r\n\t\t\tif(Hop.call(watchers, pos)){\r\n\t\t\t\twatcher = watchers[pos];\r\n\t\t\t\tif(omitCallback){\r\n\t\t\t\t\tif(watcher.$$canOmit){\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\twatcher.call(null, state);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconst setAppState = function(appState) {\r\n\r\n\t\t\teach(appState, (isolatedState, storeTitle) => {\r\n\r\n\t\t\t\tconst area = new Area(storeTitle);\r\n\r\n\t\t\t\tarea.put(isolatedState);\r\n\t\t\t\r\n\t\t\t});\r\n\r\n\t\t\tfireWatchers(appState, true);\r\n\t};\r\n\r\n    const getAppState = function() {\r\n\r\n\t        const appStateData = {};\r\n\t        let key;\r\n\t        let indexStart;\r\n\t        let indexEnd;\r\n\t        let values;\r\n\t        let _data;\r\n\r\n\t        if(('key' in sessStore) \r\n\t                && (typeof sessStore.key == 'function')){\r\n\r\n\t            // We iterate this way so we can support IE 8 + other browsers\r\n\t            for(var i=0; i < sessStore.length; i++){\r\n\t                key = sessStore.key(i);\r\n\t                _data = sessStore.getItem(key);\r\n\r\n\t                if(typeof _data !== 'string' \r\n\t                \t\t|| _data.length === 0){\r\n\t\t\t\t\t\tobserver = observers[key];\r\n\t\t\t\t\t\tif(!!observer \r\n\t\t\t\t\t\t\t&& observer.$$history.length){\r\n\t\t\t\t\t\t\t_data = observer.$$history[0];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t_data = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tappStateData[key] = (typeof _data === 'string' ? getNormalized(_data) : _data);\r\n\t\t\t\t\tconsole.log(\"hhhhhhhhhhhhhhhhh::::::::::\", appStateData, \">>>>> \", getNormalized(_data));\r\n\t            }\r\n\t        }else{\r\n\t        \r\n\t        \r\n\t            for(var i = 0; i < storeKeys.length; i++){\r\n\t                \r\n\t                key = storeKeys[i];\r\n\t                \r\n\t                if(cachedStorageKeys[key]){\r\n\r\n\t                    indexStart = wind.name.indexOf(key);\r\n\r\n\t                    indexEnd = wind.name.indexOf('|', indexStart);\r\n\r\n\t                    values = (wind.name.substring(indexStart, indexEnd)).split(':=:') || [\"\", null];\r\n\r\n\t                    _data = values[1];\r\n\r\n\t                }else {\r\n\t\t\t\t\t\tobserver = observers[key];\r\n\t\t\t\t\t\tif(!!observer\r\n\t\t\t\t\t\t\t&& observer.$$history.length){\r\n\t\t\t\t\t\t\t_data = observer.$$history[0];\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t_data = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tappStateData[key] = (typeof _data === 'string' ? getNormalized(_data) : _data);\r\n\t            }\r\n\t        }\r\n\r\n\t        return appStateData;\r\n\t};\r\n\r\n\tconst eachStore = function(fn, extractor, storeArray){\r\n\r\n\t\teach(storeKeys, extractor.bind((storeArray = []), stores));\r\n\r\n        let callable = fn;\r\n        let prevIndex = storeArray.length - 1;\r\n\r\n        const next = () => {\r\n\t\t\r\n\t\t\tlet returnVal;\r\n\r\n\t\t\tif(prevIndex >= 0){\t\r\n\t\t\t\treturnVal = Boolean(\r\n\t\t\t\t\tcallable.call(\r\n\t\t\t\t\t\t\tnull, \r\n\t\t\t\t\t\t\tstoreArray[prevIndex--], \r\n\t\t\t\t\t\t\tnext\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t}else{\r\n\t\t\t\tcallable = !0;\r\n\t\t\t\treturnVal = callable;\r\n\t\t\t}\r\n\r\n\t\t\treturn returnVal;\r\n\t\t};\r\n\r\n        next();\r\n\t};\r\n\r\n\tconst handlePromises = () => {\r\n        let promise = null;\r\n        const state = getAppState();\r\n\r\n        for(const title in _promises){\r\n\t\t\tif(Hop.call(_promises, title)){\r\n\t\t\t\tpromise = _promises[title];\r\n\t\t\t\tif(!promise.isResolved()){\r\n\t\t\t\t\tpromise.resolve();\r\n\t\t\t\t}\r\n\t\t\t\tdelete _promises[title];\r\n\t\t\t}\r\n\t\t}\r\n\r\n        waitQueue.length = 0;\r\n\r\n        fireWatchers(state);\r\n    };\r\n\r\n\tconst enforceCoverage = e => {\r\n\r\n        const _origin = enforceCoverage.$$origin;\r\n        const _tag = enforceCoverage.$$tag;\r\n        let _action = null;\r\n        let _state = null;\r\n        let _title = null;\r\n        let _hloc = null;\r\n        let _composedData = null;\r\n        let observer = null;\r\n\r\n        // Detecting IE 8 to apply mild hack on event object\r\n        if(('remainingSpace' in sessStore)){\r\n\t\t\te.key = e.detail.key;\r\n\t\t}\r\n\r\n        if(!persistStore\r\n\t\t\t|| _origin === e.key){ // if we can't find the key in the array `storeKeys`\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        _composedData = getNormalized(persistStore.getItem(_tag));\r\n\r\n        if(_tag === e.key\r\n\t\t\t&& isNullOrUndefined(_composedData)){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        _state = _composedData.state;\r\n\r\n        _action = _composedData.action;\r\n\r\n        _title = _composedData.title;\r\n\r\n        _hloc = parseInt(_composedData.historyLoc);\r\n\r\n        if(_action !== null){\r\n\t\t\toperationOnStoreSignal.$$redoActionsStack.push(_action);\r\n\t\t}\r\n\r\n        if(_hloc !== null){\r\n\t\t\tobserver = observers[_title];\r\n\t\t\tif(observer){\r\n\t\t\t\tobserver.$$historyIndex = _hloc;\r\n\t\t\t\tif(_hloc === -1){\r\n\t\t\t\t\tobserver.$$history.length = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n        if(_state){\r\n\t\t\tsetTimeout(\r\n\t\t\t\tsetAppState.bind(null, _state)\r\n\t\t\t, 0); \r\n\t\t}\r\n    };\r\n\r\n\tconst stateWatcher = e => {\r\n\r\n\t\te = e || wind.event;\r\n\r\n\t\tif(storeKeys.includes(e.detail.key)){\r\n            const storeTitle = e.detail.key;\r\n            let listeners;\r\n\r\n            if(!isNullOrUndefined(observers[storeTitle])){\r\n\r\n\t\t\t\tlisteners = observers[storeTitle].$$store_listeners;\r\n\r\n\t\t\t\tfor(let t=0; t < listeners.length; t++){\r\n\t\t\t\t\t\t    \t\t\t\r\n\t\t\t\t\tlisteners[t].call(stores[storeTitle], e.detail.type, e.detail.aspect);\r\n\t\t\t\t\t\t    \r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n\t};\r\n\r\n\t/**\r\n\t    Though IE 9 to IE 11 supports the CustomEvent constructor, IE throws an error {Object doesn't support this action} \r\n\t    whenever it's used. This weird behaviour is fixed below\r\n\t    See: https://stackoverflow.com/questions/14358599/object-doesnt-support-this-action-ie9-with-customevent-initialization\r\n\t*/\r\n\r\n\tfunction CEvent ( event, params ) {\r\n\t    let t;\r\n\t    let evt;\r\n\t    let d = wind.document;\r\n\t    params = params || { bubbles: false, cancelable: false, detail: undefined };\r\n\t    \r\n\t    try{\r\n\t\t\t    evt = d.createEvent( 'CustomEvent' );\r\n\t\t\t    evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\r\n\t\t}catch(e){\r\n\t\t\t    evt = d.createEventObject(w.event);\r\n\t\t\t  \tevt.cancelBubble = !params.bubbles;\r\n\t        \r\n\t        \tevt.returnValue = !params.cancelable;\r\n\t\t\t\t\r\n\t        if(typeof params.detail === \"object\"){\r\n\t\t\t\t\t    \r\n\t\t\t    evt.detail = params.detail;\r\n\t\t  \t}\t\r\n\t\t}\r\n\t    \r\n\t    return evt;\r\n\t}\r\n\r\n\tfunction setupConfigSettings(config, hub){\r\n\r\n\t\t \tif(config.universalCoverage){\r\n\r\n\t\t \t\tconfig.persistenceEnabled = true;\r\n\t\t \t}\r\n\r\n\t\t \tif(config.persistenceEnabled){\r\n\r\n\t\t\t\t\t// prepare Origin \r\n\t\t\t\t\tconst _origin = getAppOriginForPersist(config);\r\n\r\n\t\t\t\t\tconst _tag = generateTag(_origin);\r\n\r\n\t\t\t\t\tpersistStore.setItem(_origin, _tag);\r\n\r\n\t\t\t\t\tenforceCoverage.$$origin = _origin;\r\n\r\n\t\t\t\t\tenforceCoverage.$$tag = _tag;\r\n\r\n\t\t\t\t\tcoverageNotifier.$$canOmit = true;\r\n\r\n\t\t\t\t\tcoverageNotifier.$$tag = _tag;\r\n\r\n\t\t\t\t\thub.onDispatch(coverageNotifier);\r\n\t\t\t}\r\n\r\n            if(config.autoRehydrate === true){\r\n\t\t    \r\n\t\t\t    \tlet data = null;\r\n\t                    \r\n\t                if(!isNullOrUndefined(enforceCoverage.$$tag) \r\n\t                        && persistStore){\r\n\t                    \tdata = getNormalized(persistStore.getItem(enforceCoverage.$$tag));\r\n\t\t\t    \t}\r\n\t\t\t    \r\n\t\t\t    \tif(data &&\r\n\t\t\t    \t\t\t(data instanceof Object)\r\n\t                            && data.state){\r\n\t                        setAppState(data.state);\r\n\t                        this.updateAutoRehydrationState();\r\n                  \t}\r\n            }\r\n\r\n\t\t\tif(!config.runtime.spaMode){\r\n\t\t\t\t\r\n\t\t\t\tif(typeof config.runtime.shutDownHref === 'string'\r\n\t\t\t\t\t&& config.runtime.shutDownHref.length != 0){\r\n\r\n\t\t\t\t\twind.onbeforeunload = $createBeforeTearDownCallback(config);\r\n\t\t\t\t\r\n\t\t\t\t\twind.onunload = $createTearDownCallback(hub);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\r\n\t\t\t\tif(typeof config.runtime.shutDownHref === 'string'\r\n\t\t\t\t\t&& config.runtime.shutDownHref.length != 0){\r\n\r\n\t\t\t\t\tif(wind.addEventListener){\r\n\t\t\t\t\t\twind.document.documentElement.addEventListener('click', $createBeforeTearDownCallback(config), false);\r\n\t\t\t\t\t\twind.document.addEventListener('click', $createTearDownCallback(hub), false);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\twind.document.documentElement.attachEvent('onclick', $createBeforeTearDownCallback(config));\r\n\t\t\t\t\t\twind.document.attachEvent('onclick', $createTearDownCallback(hub), false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tconst Area = function(key){\r\n\r\n\t\t\tthis.put = value => {\r\n\t            \r\n\t\t\t\t/* \r\n\t\t\t\t\tIn IE 8-9, writing to sessionStorage is done asynchronously (other browsers write synchronously)\r\n\t\t\t\t\twe need to fix this by using IE proprietary methods\r\n\r\n\t\t\t\t\tSee: https://www.nczonline.net/blog/2009/07/21/introduction-to-sessionstorage/ \r\n\t\t\t\t*/\r\n\r\n        \t\tlet indexStart;\r\n\r\n        \t\tlet indexEnd;\r\n\t\t\r\n        \t\tconst isIE8Storage = ('remainingSpace' in sessStore) && (mode === 8);\r\n\r\n\t            \t\t// Detecting IE 8 to enable forced sync\r\n\t\t\t\tif(isIE8Storage){\r\n\t\t\t\t\tif(typeof sessStore.begin == 'function'){\r\n\t\t\t\t\t\tsessStore.begin();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n        \t\ttry{\r\n\r\n\t\t\t\t\tsessStore.setItem(key, setNormalized(value));\r\n\t\t\t\t\t\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\t\r\n\t\t\t\t\t/* This is a fallback to support Opera Mini 4.4+ on Mobile */\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(cachedStorageKeys[key]){\r\n\t\t\t\t\t\t// we're in overwrite mode, so clear `key` out and push in update (below)\r\n\t\t\t\t\t\tindexStart = wind.name.indexOf(key);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tindexEnd = wind.name.indexOf('|', indexStart);\r\n\r\n\t\t\t\t\t\twind.name = wind.name.replace(wind.name.substring(indexStart, indexEnd), '');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(wind.name === \"\"){\r\n\r\n\t\t\t\t\t\twind.name = `${key}:=:${setNormalized(value)}|`;\r\n\r\n\t\t\t\t\t}else{\r\n\r\n\t\t\t\t\t\twind.name += `${key}:=:${setNormalized(value)}|`;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tcachedStorageKeys[key] = 1;\r\n\t\t\t\t}\r\n\r\n        \t\tif(isIE8Storage){\r\n\t\t\t\t\tif(typeof sessStore.commit == 'function'){\r\n\t\t\t\t\t\tsessStore.commit();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t            return key;\r\n\t        };\r\n\r\n\t\t\tthis.get = () => {\r\n\r\n\t\t\t\tlet indexStart, indexEnd, values;\r\n\t\t\t\t\r\n\t\t\t\t/* This is a fallback to support Opera Mini 4.4+ on Mobile */\r\n\t\t\t\t\r\n\t\t\t\ttry{\r\n\t\t\t\t\r\n\t\t\t\t\treturn getNormalized(sessStore.getItem(key)) || null;\r\n\t\t\t\t\t\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\r\n\t\t\t\t\tif(cachedStorageKeys[key]){\r\n\r\n\t\t\t\t\t\tindexStart = wind.name.indexOf(key);\r\n\r\n\t\t\t\t\t\tindexEnd = wind.name.indexOf('|', indexStart);\r\n\r\n\t\t\t\t\t\tvalues = (wind.name.substring(indexStart, indexEnd)).split(':=:') || [0, 0];\r\n\r\n\t\t\t\t\t\treturn getNormalized(values[1]) || null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tthis.del = () => {\r\n\r\n\t\t\t\t\tlet indexStart;\r\n\r\n\t\t\t\t\tlet indexEnd;\r\n\t\t\t\t\t/* This is a fallback to support Opera Mini 4.4+ on Mobile */\r\n\t\t\t\t\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn sessStore.removeItem(key);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\r\n\t\t\t\t\t\tif(cachedStorageKeys[key]){\r\n\r\n\t\t\t\t\t\t\t// we're in delete mode\r\n\t\t\t\t\t\t\tindexStart = wind.name.indexOf(key);\r\n\r\n\t\t\t\t\t\t\tindexEnd = wind.name.indexOf('|', indexStart);\r\n\r\n\t\t\t\t\t\t\twind.name = wind.name.replace(wind.name.substring(indexStart, indexEnd), '');\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tdelete cachedStorageKeys[key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\treturn this;\r\n\t};\r\n\r\n\tclass Dispatcher {\r\n\r\n\t\tconstructor() {\r\n\r\n            \tthis.middlewares = [];\r\n\r\n            \toperationOnStoreSignal.$$undoActionsStack = [];\r\n\r\n            \toperationOnStoreSignal.$$redoActionsStack = [];\r\n        }\r\n\r\n        updateAutoRehydrationState() {\r\n            \r\n            \tautoRehydrationOccured = true;\r\n        }\r\n\r\n        getAutoRehydrationState() {\r\n            \r\n            \treturn autoRehydrationOccured;\r\n        }\r\n\r\n        setMiddleware(middleware) {\r\n            \r\n                if(typeof middleware === 'function'\r\n                    /*&& (middleware.length >= 2)*/){\r\n\r\n                    return this.middlewares.push(middleware);\r\n                }\r\n\r\n                throw new Error(\"Radixx: Inavlid Middleware Callback - Must be a Function with Parameters ( >= 2 )\");\r\n\r\n        }\r\n\r\n        hasMiddleware() {\r\n            \r\n                return (this.middlewares.length > 0);\r\n\r\n        }\r\n\r\n        initCatchers(userConfig, hub) {\r\n\r\n        \t\tif(isNullOrUndefined(config)){\r\n\r\n\t\t\t\t\tconfig = extend(userConfig, defaultConfig);\r\n\r\n\t\t\t\t\tsetupConfigSettings.apply(this, [config, hub]);\r\n        \t\t}\r\n\r\n                if(wind.document.addEventListener){\r\n                    /* IE 9+, W3C browsers all expect the 'storage' event to be bound to the window */\r\n                    if(config.universalCoverage){\r\n                        wind.addEventListener('storage', enforceCoverage, false);\r\n                    }\r\n\r\n                    wind.document.addEventListener('storesignal', stateWatcher, false);\r\n\r\n                }else if(wind.document.attachEvent){\r\n                    /* IE 8 expects the 'storage' event handler to be bound to the document \r\n                        and not to the window */\r\n                    if(config.universalCoverage){\r\n                        wind.document.attachEvent('onstorage', enforceCoverage);\r\n                    }\r\n\r\n                    wind.document.attachEvent('onstoresignal', stateWatcher);\r\n                }\r\n\r\n        }\r\n\r\n        getRegistration(title) {\r\n\r\n\t            if(Hop.call(observers, title)){\r\n\t                \r\n\t                return observers[title];\r\n\t            }\r\n\r\n\t            return {};\r\n\t\t}\r\n\r\n\t\tregister(title, observer, defaultStoreContainer) {\r\n                \r\n                if(Hop.call(observers, title)){\r\n                    \r\n                    if('$$history' in observers[title]\r\n                         && typeof observer.$$history == 'undefined'){\r\n                        if(!stores[title]){ // If the store doesn't have any change listeners registered\r\n                            \r\n                            throw new Error(\"Radixx: Cannot Overwrite existing store registration\");\r\n                        \r\n                            return;\r\n                        }\r\n\r\n                        observer.$$history = observers[title].$$history;\r\n                        observer.$$historyIndex = observers[title].$$historyIndex;\r\n                        observer.$$store_listeners = observers[title].$$store_listeners;\r\n                        observers[title] = observer;\r\n                    }\r\n                }else{\r\n\r\n                    observer.$$store_listeners = [];\r\n                    observer.$$history = [(\r\n                            !!defaultStoreContainer ? \r\n                            defaultStoreContainer :\r\n                                 null\r\n                    )];\r\n                    observer.$$historyIndex = 0;\r\n                    observers[title] = observer;\r\n                    storeKeys.push(title);\r\n                }\r\n                \r\n                return true;\r\n        }\r\n\r\n        watch(callback) {\r\n\r\n                watchers.push(callback);\r\n        }\r\n\r\n        setStoreListener(store, callback) {\r\n\r\n            \tconst title = store.getTitle();\r\n\r\n\t            if(!isNullOrUndefined(observers[title])){\r\n\r\n\t                if(typeof callback == \"function\"){\r\n\t                    stores[title] = store;\r\n\t                    observers[title].$$store_listeners.push(callback);\r\n\t                }\r\n\t            }\r\n        }\r\n\r\n        unsetStoreListener(store, callback) {\r\n\r\n\t            const title = store.getTitle();\r\n\r\n\t            if(!isNullOrUndefined(observers[title])){\r\n\t                if(typeof callback == \"function\"){\r\n\r\n\t                    const pos = observers[title].$$store_listeners.indexOf(callback);\r\n\t                    observers[title].$$store_listeners.splice(pos, 1);\r\n\t                }\r\n\t            }\r\n\r\n        }\r\n\r\n        signalUnique(hydrateAction) {\r\n\r\n\t            if(hydrateAction.source != 'hydrate'){\r\n\t                return;\r\n\t            }\r\n\r\n\t            // Pass this on to the event queue [await]\r\n\t            wind.setTimeout(handlePromises, 0);\r\n\r\n\t            const stateArea = new Area(hydrateAction.target), regFunc = observers[hydrateAction.target];\r\n\r\n\t            operationOnStoreSignal.$$redoActionsStack.length = 0;\r\n\r\n\t            operationOnStoreSignal.$$redoActionsStack.push(hydrateAction);\r\n\r\n\t            regFunc.$$history.length = 0; // clear out the store state since this is a hydrate call\r\n\r\n\t            regFunc.historyIndex = -1;\r\n\r\n\t            operationOnStoreSignal(...[\r\n\t\t\t\t\tregFunc, \r\n\t\t\t\t\tnull, \r\n\t\t\t\t\tstateArea,\r\n\t\t\t\t\thydrateAction\r\n\t\t\t\t]);\r\n\r\n        }\r\n\r\n        handleStoreMutation(store, mutationType) {\r\n\r\n\t            if(!mutationType){\r\n\t                return;\r\n\t            }\r\n\r\n\t            const storeTitle = store.getTitle();\r\n\t            const isolatedState = {}; \r\n\t            const regFunc = this.getRegistration(storeTitle);\r\n\t            const stateArea = new Area(storeTitle);\r\n\r\n\t                switch(mutationType){\r\n\r\n\t                    case 'undo':\r\n\t                        if(store.canUndo()){\r\n\t                            \r\n\t                            --regFunc.$$historyIndex;\r\n\r\n\t                            isolatedState[storeTitle] = operationOnStoreSignal(...[\r\n\t\t\t\t\t\t\t\t\tregFunc,\r\n\t\t\t\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\t\t\t\tstateArea,\r\n\t\t\t\t\t\t\t\t\tnull\r\n\t\t\t\t\t\t\t\t]); \r\n\r\n\t                            // Pass this on to the event queue \r\n\t                            wind.setTimeout(fireWatchers.bind(null, isolatedState), 0);\r\n\r\n\t                            return true;\r\n\t                        }\r\n\t                    break;\r\n\t                    case 'redo':\r\n\t                        if(store.canRedo()){\r\n\r\n\t                            ++regFunc.$$historyIndex;\r\n\r\n\t                            isolatedState[storeTitle] = operationOnStoreSignal(...[\r\n\t\t\t\t\t\t\t\t\tregFunc,\r\n\t\t\t\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\t\t\t\tstateArea,\r\n\t\t\t\t\t\t\t\t\tnull\r\n\t\t\t\t\t\t\t\t]);\r\n\r\n\t                            // Pass this on to the event queue \r\n\t                            wind.setTimeout(fireWatchers.bind(null, isolatedState), 0);\r\n\r\n\t                            return true;\r\n\r\n\t                        }\r\n\t                    break;\r\n\t                }\r\n\r\n\t                return false;\r\n        }\r\n\r\n        deletePersistenceTagAndData(){\r\n\r\n        \tif(isNullOrUndefined(config)){\r\n\r\n        \t\treturn false;\r\n        \t}\r\n\r\n        \tconst _origin = getAppOriginForPersist(config);\r\n\r\n\t\t\tconst _tag = generateTag(_origin);\r\n\r\n\t\t\tpersistStore.removeItem(_origin);\r\n\r\n\t\t\tpersistStore.removeItem(_tag);\r\n\r\n\t\t\treturn true;\r\n        }\r\n\r\n        rebuildStateFromActions() {\r\n\r\n\t            const actionsStack = operationOnStoreSignal.$$redoActionsStack;\r\n\r\n\t            each(actionsStack, (action, index) => {\r\n\r\n\t                let stateArea;\r\n\r\n\t                for(title in observers){\r\n\t                    if(Hop.call(observers, title)){\r\n\r\n\t                        stateArea = new Area(title);\r\n\r\n\t                        observers[title].call(action, stateArea.get());\r\n\t                    }\r\n\t                }\r\n\r\n\t            }, operationOnStoreSignal);\r\n        }\r\n\r\n        iterateOnStore(...args){\r\n\r\n        \treturn eachStore(...args);\r\n        }\r\n\r\n        signal(action) {\r\n\r\n\t            let compactedFunc = null;\r\n\r\n\t            // this is the function that does the actual dispatch of the \r\n\t            \r\n\t            const baseDispatchCallback = (observers, dispatcher, action, prevState) => {\r\n\r\n\t\t\t\t\t\tlet title, stateArea = null; \r\n\r\n\t\t\t\t\t\toperationOnStoreSignal.$$redoActionsStack.push(action);\r\n\r\n\t\t\t\t\t\tfor(title in observers){\r\n\t\t\t\t\t\t\tif(Hop.call(observers, title)){\r\n\r\n\t\t\t\t\t\t\t\tstateArea = new Area(title);\r\n\r\n\t\t\t\t\t\t\t\toperationOnStoreSignal(...[\r\n\t                                observers[title], \r\n\t                                dispatcher.queueing, \r\n\t                                stateArea,\r\n\t                                action\r\n\t                            ]);\r\n\t\t\t\t\t\t\t}\t\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn getAppState();\r\n\t\t\t\t};\r\n\r\n\t            const boundBaseDispatchCallback = baseDispatchCallback.bind(null, observers, this);\r\n\r\n\t            const adjoiner = {\r\n\t                    /*createActionObject:function(_data, _type){\r\n\t                         \r\n\t                         return {\r\n\t                            source:\"\",\r\n\t                            actionType:_type,\r\n\t                            actionData:_data,\r\n\t                            actionKey:null\r\n\t                         };\r\n\t                    },*/\r\n\t                    createDispatchResolver(_action) {\r\n\r\n\t                        return boundBaseDispatchCallback.bind(null, _action);\r\n\t                    }\r\n\t            };\r\n\r\n\t            const _hasMiddleware = this.hasMiddleware();\r\n\r\n\r\n\t            // Some validation - just to make sure everything is okay\r\n\t            if(!(action.source in dispatchRegistry)){\r\n\r\n\t                return;\r\n\t            }\r\n\r\n\t            // determine if there are middleware callbacks registered\r\n\t            if(_hasMiddleware){ \r\n\t                \r\n\t                // collapse all middleware callbacks into a single callback\r\n\t                compactedFunc = this.middlewares.concat(\r\n\t                                    boundBaseDispatchCallback\r\n\t                                ).reduceRight((bound, middleware) => middleware.bind(null,\r\n\t                    bound\r\n\t                ));\r\n\r\n\t            }else {\r\n\r\n\t                compactedFunc = baseDispatchCallback;\r\n\t            }\r\n\r\n\t            // Pass this on to the event queue \r\n\t            wind.setTimeout(handlePromises, 0);\r\n\r\n\t            // begin cascading calls to the middlewares in turn\r\n\t            // from the last attached middleware all the way up\r\n\t            // to the first middleware until the action\r\n\t            // is finally dispatched\r\n\r\n\t            if(!isNullOrUndefined(compactedFunc)){\r\n\r\n\t                compactedFunc.apply(_hasMiddleware ? adjoiner : null, [action, getAppState()]);\r\n\r\n\t            }\r\n\t\t}\r\n\r\n\t\tsetActionsRegistry(regId){\r\n\r\n\t\t\tdispatchRegistry[regId] = {actionTypes:[]};\r\n\t\t}\r\n\r\n\t\taddToActonsRegistry(id, vector){\r\n\r\n\t\t\tif(! isNullOrUndefined(dispatchRegistry[id])){\r\n\t\t\t\t\tdispatchRegistry[id].actionTypes.push(\r\n\t\t\t\t\t\tvector\r\n\t\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tunregister(title) {\r\n\r\n\t            let observer, store, index;\r\n\r\n\t            if(!isNullOrUndefined(observers[title])){\r\n\t                // initial clean-up\r\n\r\n\t                observer = observers[title];\r\n\t                store = stores[title];\r\n\t                observer.$$store_listeners.length = 0;\r\n\t                observer.$$store_listeners = null;\r\n\t                observer.$$historyIndex = -1;\r\n\t                observer.$$history.length = 0;\r\n\t                observer.$$history = null;\r\n\t                \r\n\t                // more clean-up (freeing memory)\r\n\t                delete observers[title];\r\n\t                observer = null;\r\n\t                \r\n\t                delete stores[title];\r\n\t                store = null;\r\n\r\n\t                index = storeKeys.indexOf(title);\r\n\r\n\t                if(index != -1){\r\n\t                    storeKeys.splice(index, 1);\r\n\t                }\r\n\t            }\r\n\t\t}\r\n\r\n\t} \r\n\r\nexport { Dispatcher, Area }","import { wind } from './routines/basics.js';\r\n\r\nconst Helpers = {\r\n        isEqual(former, latter) {\r\n                      if (former === latter) {\r\n                        return true;\r\n                      }\r\n\r\n                      if (typeof former !== 'object' || former === null ||\r\n                          typeof latter !== 'object' || latter === null) {\r\n                            return false;\r\n                      }\r\n\r\n                      const keysA = wind.Object.keys(former);\r\n                      const keysB = wind.Object.keys(latter);\r\n\r\n                      if (keysA.length !== keysB.length) {\r\n                        return false;\r\n                      }\r\n\r\n                      // Test for A's keys different from B.\r\n                      const bHasOwnProperty = wind.hasOwnProperty.bind(latter);\r\n                      for (let i = 0; i < keysA.length; i++) {\r\n                        if (!bHasOwnProperty(keysA[i]) || former[keysA[i]] !== latter[keysA[i]]) {\r\n                          return false;\r\n                        }\r\n                      }\r\n        }\r\n};\r\n\r\nexport { Helpers }\r\n","import { wind } from './routines/basics.js';\r\n\r\nconst Payload = {\r\n        type:{\r\n                     \"array\":\"array\",\r\n                     \"date\":\"date\",\r\n                     \"string\":\"string\",\r\n                     \"regexp\":\"regexp\",\r\n                     \"boolean\":\"boolean\",\r\n                     \"function\":\"function\",\r\n                     \"object\":\"object\",\r\n                     \"number\":\"number\",\r\n                     error(value) {\r\n\r\n                            return (value instanceof wind.Error || value instanceof wind.TypeError);\r\n                     },\r\n                     nullable(value) {\r\n\r\n                            return (value === null || value === undefined);\r\n                     },\r\n                     \"numeric\":{\r\n                        Int(value) {\r\n                            \r\n                            return wind.isFinite(value) && (value === wind.parseInt(value))\r\n                        },\r\n                        Float(value) {\r\n\r\n                            return wind.isFinite(value) && (value === wind.parseFloat(value))\r\n                        }\r\n                     },\r\n                     any(value) {\r\n                            \r\n                            return (value !== null || value !== undefined);\t \t\t\t\r\n                     }\r\n          }\r\n};\r\n\r\nexport { Payload }\r\n"],"sourceRoot":""}